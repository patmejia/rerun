// NOTE: This file was autogenerated by re_types_builder; DO NOT EDIT.
// Based on "crates/re_types/definitions/rerun/datatypes/tensor_meaning.fbs"

#pragma once

#include <arrow/type_fwd.h>
#include <cstdint>
#include <cstring>
#include <utility>

namespace rerun {
    namespace datatypes {
        namespace detail {
            enum class TensorMeaningTag : uint8_t {
                /// Having a special empty state makes it possible to implement move-semantics. We
                /// need to be able to leave the object in a state which we can run the destructor
                /// on.
                NONE = 0,
                Unknown,
                ClassId,
                Depth,
            };

            union TensorMeaningData {
                bool unknown;

                bool class_id;

                bool depth;

                TensorMeaningData() {}

                ~TensorMeaningData() {}

                void swap(TensorMeaningData &other) noexcept {
                    // This bitwise swap would fail for self-referential types, but we don't have
                    // any of those.
                    char temp[sizeof(TensorMeaningData)];
                    void *otherbytes = reinterpret_cast<void *>(&other);
                    void *thisbytes = reinterpret_cast<void *>(this);
                    std::memcpy(temp, thisbytes, sizeof(TensorMeaningData));
                    std::memcpy(thisbytes, otherbytes, sizeof(TensorMeaningData));
                    std::memcpy(otherbytes, temp, sizeof(TensorMeaningData));
                }
            };
        } // namespace detail

        struct TensorMeaning {
            TensorMeaning() : _tag(detail::TensorMeaningTag::NONE) {}

            TensorMeaning(const TensorMeaning &other) : _tag(other._tag) {
                const void *otherbytes = reinterpret_cast<const void *>(&other._data);
                void *thisbytes = reinterpret_cast<void *>(&this->_data);
                std::memcpy(thisbytes, otherbytes, sizeof(detail::TensorMeaningData));
            }

            TensorMeaning &operator=(const TensorMeaning &other) noexcept {
                TensorMeaning tmp(other);
                this->swap(tmp);
                return *this;
            }

            TensorMeaning(TensorMeaning &&other) noexcept : _tag(detail::TensorMeaningTag::NONE) {
                this->swap(other);
            }

            TensorMeaning &operator=(TensorMeaning &&other) noexcept {
                this->swap(other);
                return *this;
            }

            void swap(TensorMeaning &other) noexcept {
                auto tag_temp = this->_tag;
                this->_tag = other._tag;
                other._tag = tag_temp;
                this->_data.swap(other._data);
            }

            static TensorMeaning unknown(bool unknown) {
                TensorMeaning self;
                self._tag = detail::TensorMeaningTag::Unknown;
                self._data.unknown = std::move(unknown);
                return self;
            }

            static TensorMeaning class_id(bool class_id) {
                TensorMeaning self;
                self._tag = detail::TensorMeaningTag::ClassId;
                self._data.class_id = std::move(class_id);
                return self;
            }

            static TensorMeaning depth(bool depth) {
                TensorMeaning self;
                self._tag = detail::TensorMeaningTag::Depth;
                self._data.depth = std::move(depth);
                return self;
            }

            /// Returns the arrow data type this type corresponds to.
            static const std::shared_ptr<arrow::DataType> &to_arrow_datatype();

            /// Creates a new array builder with an array of this type.
            static arrow::Result<std::shared_ptr<arrow::DenseUnionBuilder>> new_arrow_array_builder(
                arrow::MemoryPool *memory_pool
            );

            /// Fills an arrow array builder with an array of this type.
            static arrow::Status fill_arrow_array_builder(
                arrow::DenseUnionBuilder *builder, const TensorMeaning *elements,
                size_t num_elements
            );

          private:
            detail::TensorMeaningTag _tag;
            detail::TensorMeaningData _data;
        };
    } // namespace datatypes
} // namespace rerun
